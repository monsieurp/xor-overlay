diff -Naur linux-5.12.13/arch/x86/entry/syscalls/syscall_32.tbl linux-5.12.13-r1/arch/x86/entry/syscalls/syscall_32.tbl
--- linux-5.12.13/arch/x86/entry/syscalls/syscall_32.tbl	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/arch/x86/entry/syscalls/syscall_32.tbl	2021-06-29 19:27:35.164349654 -0400
@@ -447,3 +447,7 @@
 440	i386	process_madvise		sys_process_madvise
 441	i386	epoll_pwait2		sys_epoll_pwait2		compat_sys_epoll_pwait2
 442	i386	mount_setattr		sys_mount_setattr
+
+# This one is a temporary number, designed for no clashes.
+# Nothing but DTrace should use it.
+473	i386	waitfd			sys_waitfd
diff -Naur linux-5.12.13/arch/x86/entry/syscalls/syscall_64.tbl linux-5.12.13-r1/arch/x86/entry/syscalls/syscall_64.tbl
--- linux-5.12.13/arch/x86/entry/syscalls/syscall_64.tbl	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/arch/x86/entry/syscalls/syscall_64.tbl	2021-06-29 19:27:31.781016209 -0400
@@ -365,6 +365,10 @@
 441	common	epoll_pwait2		sys_epoll_pwait2
 442	common	mount_setattr		sys_mount_setattr
 
+# This one is a temporary number, designed for no clashes.
+# Nothing but DTrace should use it.
+473	common	waitfd			sys_waitfd
+
 #
 # Due to a historical design error, certain syscalls are numbered differently
 # in x32 as compared to native x86_64.  These syscalls have numbers 512-547.
diff -Naur linux-5.12.13/drivers/vfio/virqfd.c linux-5.12.13-r1/drivers/vfio/virqfd.c
--- linux-5.12.13/drivers/vfio/virqfd.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/drivers/vfio/virqfd.c	2021-06-29 19:28:07.604350724 -0400
@@ -79,7 +79,8 @@
 }
 
 static void virqfd_ptable_queue_proc(struct file *file,
-				     wait_queue_head_t *wqh, poll_table *pt)
+				     wait_queue_head_t *wqh, poll_table *pt,
+				     unsigned long unused)
 {
 	struct virqfd *virqfd = container_of(pt, struct virqfd, pt);
 	add_wait_queue(wqh, &virqfd->wait);
diff -Naur linux-5.12.13/drivers/vhost/vhost.c linux-5.12.13-r1/drivers/vhost/vhost.c
--- linux-5.12.13/drivers/vhost/vhost.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/drivers/vhost/vhost.c	2021-06-29 19:28:40.107685131 -0400
@@ -152,7 +152,7 @@
 }
 
 static void vhost_poll_func(struct file *file, wait_queue_head_t *wqh,
-			    poll_table *pt)
+				poll_table *pt, unsigned long unused)
 {
 	struct vhost_poll *poll;
 
diff -Naur linux-5.12.13/fs/Makefile linux-5.12.13-r1/fs/Makefile
--- linux-5.12.13/fs/Makefile	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/fs/Makefile	2021-06-29 19:29:13.467686226 -0400
@@ -31,6 +31,7 @@
 obj-$(CONFIG_TIMERFD)		+= timerfd.o
 obj-$(CONFIG_EVENTFD)		+= eventfd.o
 obj-$(CONFIG_USERFAULTFD)	+= userfaultfd.o
+obj-$(CONFIG_WAITFD) 		+= waitfd.o
 obj-$(CONFIG_AIO)               += aio.o
 obj-$(CONFIG_IO_URING)		+= io_uring.o
 obj-$(CONFIG_IO_WQ)		+= io-wq.o
diff -Naur linux-5.12.13/fs/aio.c linux-5.12.13-r1/fs/aio.c
--- linux-5.12.13/fs/aio.c	2021-06-29 19:26:03.257679970 -0400
+++ linux-5.12.13-r1/fs/aio.c	2021-06-29 19:29:40.147687102 -0400
@@ -1720,7 +1720,7 @@
 
 static void
 aio_poll_queue_proc(struct file *file, struct wait_queue_head *head,
-		struct poll_table_struct *p)
+		struct poll_table_struct *p, unsigned long fixed_event)
 {
 	struct aio_poll_table *pt = container_of(p, struct aio_poll_table, pt);
 
diff -Naur linux-5.12.13/fs/eventpoll.c linux-5.12.13-r1/fs/eventpoll.c
--- linux-5.12.13/fs/eventpoll.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/fs/eventpoll.c	2021-06-29 19:32:39.507693005 -0400
@@ -153,6 +153,9 @@
 	/* The file descriptor information this item refers to */
 	struct epoll_filefd ffd;
 
+	/* fd always raises this fixed event. */
+	unsigned long fixed_event;
+
 	/* List containing poll wait queues */
 	struct eppoll_entry *pwqlist;
 
@@ -1206,6 +1209,13 @@
 	if (!(epi->event.events & EPOLLEXCLUSIVE))
 		ewake = 1;
 
+	/*
+	 * If this fd type has a hardwired event which should override the key
+	 * (e.g. if it is waiting on a non-file waitqueue), jam it in here.
+	 */
+	if (epi->fixed_event)
+		key = (void *)epi->fixed_event;
+
 	if (pollflags & POLLFREE) {
 		/*
 		 * If we race with ep_remove_wait_queue() it can miss
@@ -1230,7 +1240,7 @@
  * target file wakeup lists.
  */
 static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,
-				 poll_table *pt)
+				poll_table *pt, unsigned long fixed_event)
 {
 	struct ep_pqueue *epq = container_of(pt, struct ep_pqueue, pt);
 	struct epitem *epi = epq->epi;
@@ -1239,6 +1249,12 @@
 	if (unlikely(!epi))	// an earlier allocation has failed
 		return;
 
+	if (fixed_event & !(epi->event.events & fixed_event))
+		return;
+
+	if (fixed_event)
+		epi->fixed_event = fixed_event;
+
 	pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL);
 	if (unlikely(!pwq)) {
 		epq->epi = NULL;
@@ -1460,6 +1476,7 @@
 	epi->ep = ep;
 	ep_set_ffd(&epi->ffd, tfile, fd);
 	epi->event = *event;
+	epi->fixed_event = 0;
 	epi->next = EP_UNACTIVE_PTR;
 
 	if (tep)
diff -Naur linux-5.12.13/fs/io_uring.c linux-5.12.13-r1/fs/io_uring.c
--- linux-5.12.13/fs/io_uring.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/fs/io_uring.c	2021-06-29 19:33:40.701028344 -0400
@@ -5103,7 +5103,8 @@
 }
 
 static void io_async_queue_proc(struct file *file, struct wait_queue_head *head,
-			       struct poll_table_struct *p)
+				struct poll_table_struct *p,
+				unsigned long fixed_event)
 {
 	struct io_poll_table *pt = container_of(p, struct io_poll_table, pt);
 	struct async_poll *apoll = pt->req->apoll;
@@ -5398,7 +5399,7 @@
 }
 
 static void io_poll_queue_proc(struct file *file, struct wait_queue_head *head,
-			       struct poll_table_struct *p)
+				struct poll_table_struct *p, unsigned long fixed_event)
 {
 	struct io_poll_table *pt = container_of(p, struct io_poll_table, pt);
 
diff -Naur linux-5.12.13/fs/select.c linux-5.12.13-r1/fs/select.c
--- linux-5.12.13/fs/select.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/fs/select.c	2021-06-29 19:35:47.404365839 -0400
@@ -116,7 +116,7 @@
  * poll table.
  */
 static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,
-		       poll_table *p);
+		       poll_table *p, unsigned long fixed_event);
 
 void poll_initwait(struct poll_wqueues *pwq)
 {
@@ -212,6 +212,14 @@
 	struct poll_table_entry *entry;
 
 	entry = container_of(wait, struct poll_table_entry, wait);
+
+	/*
+	 * If this fd type has a hardwired key which should override the key
+	 * (e.g. if it is waiting on a non-file waitqueue), jam it in here.
+	 */
+	if (entry->fixed_key)
+		key = (void *)entry->fixed_key;
+
 	if (key && !(key_to_poll(key) & entry->key))
 		return 0;
 	return __pollwake(wait, mode, sync, key);
@@ -219,15 +227,22 @@
 
 /* Add a new entry */
 static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,
-				poll_table *p)
+				poll_table *p, unsigned long fixed_event)
 {
 	struct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);
-	struct poll_table_entry *entry = poll_get_entry(pwq);
+	struct poll_table_entry *entry;
+
+	if (fixed_event && !(p->_key & fixed_event))
+		return;
+
+	entry = poll_get_entry(pwq);
 	if (!entry)
 		return;
+
 	entry->filp = get_file(filp);
 	entry->wait_address = wait_address;
 	entry->key = p->_key;
+	entry->fixed_key = fixed_event;
 	init_waitqueue_func_entry(&entry->wait, pollwake);
 	entry->wait.private = pwq;
 	add_wait_queue(wait_address, &entry->wait);
diff -Naur linux-5.12.13/fs/waitfd.c linux-5.12.13-r1/fs/waitfd.c
--- linux-5.12.13/fs/waitfd.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-5.12.13-r1/fs/waitfd.c	2021-06-29 19:36:07.597699842 -0400
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *  fs/waitfd.c
+ *
+ *  Copyright (C) 2008  Red Hat, Casey Dahlin <cdahlin@redhat.com>
+ *
+ *  Largely derived from fs/signalfd.c
+ */
+
+#include <linux/file.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/list.h>
+#include <linux/anon_inodes.h>
+#include <linux/syscalls.h>
+
+long kernel_wait4(pid_t upid, int __user *stat_addr,
+	      int options, struct rusage __user *ru);
+
+struct waitfd_ctx {
+	int	options;
+	pid_t	upid;
+};
+
+static int waitfd_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+static unsigned int waitfd_poll(struct file *file, poll_table *wait)
+{
+	struct waitfd_ctx *ctx = file->private_data;
+	long value;
+
+	poll_wait_fixed(file, &current->signal->wait_chldexit, wait,
+		POLLIN);
+
+	value = kernel_wait4(ctx->upid, NULL, ctx->options | WNOHANG | WNOWAIT,
+			 NULL);
+	if (value > 0 || value == -ECHILD)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+/*
+ * Returns a multiple of the size of a stat_addr, or a negative error code. The
+ * "count" parameter must be at least sizeof(int).
+ */
+static ssize_t waitfd_read(struct file *file, char __user *buf, size_t count,
+			     loff_t *ppos)
+{
+	struct waitfd_ctx *ctx = file->private_data;
+	int __user *stat_addr = (int *)buf;
+	int flags = ctx->options;
+	ssize_t ret, total = 0;
+
+	count /= sizeof(int);
+	if (!count)
+		return -EINVAL;
+
+	if (file->f_flags & O_NONBLOCK)
+		flags |= WNOHANG;
+
+	do {
+		ret = kernel_wait4(ctx->upid, stat_addr, flags, NULL);
+		if (ret == 0)
+			ret = -EAGAIN;
+		if (ret == -ECHILD)
+			ret = 0;
+		if (ret <= 0)
+			break;
+
+		stat_addr++;
+		total += sizeof(int);
+	} while (--count);
+
+	return total ? total : ret;
+}
+
+static const struct file_operations waitfd_fops = {
+	.release	= waitfd_release,
+	.poll		= waitfd_poll,
+	.read		= waitfd_read,
+	.llseek		= noop_llseek,
+};
+
+SYSCALL_DEFINE4(waitfd, int __maybe_unused, which, pid_t, upid, int, options,
+		int __maybe_unused, flags)
+{
+	int ufd;
+	struct waitfd_ctx *ctx;
+
+	/*
+	 * Options validation from kernel_wait4(), minus WNOWAIT, which is
+	 * only used by our polling implementation.  If WEXITED or WSTOPPED
+	 * are provided, silently remove them (for backward compatibility with
+	 * older callers).
+	 */
+	options &= ~(WEXITED | WSTOPPED);
+	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
+			__WNOTHREAD|__WCLONE|__WALL))
+		return -EINVAL;
+
+	ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->options = options;
+	ctx->upid = upid;
+
+	ufd = anon_inode_getfd("[waitfd]", &waitfd_fops, ctx,
+			       O_RDWR | flags | ((options & WNOHANG) ?
+						 O_NONBLOCK | 0 : 0));
+	/*
+	 * Use the fd's nonblocking state from now on, since that can change.
+	 */
+	ctx->options &= ~WNOHANG;
+
+	if (ufd < 0)
+		kfree(ctx);
+
+	return ufd;
+}
diff -Naur linux-5.12.13/include/linux/poll.h linux-5.12.13-r1/include/linux/poll.h
--- linux-5.12.13/include/linux/poll.h	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/include/linux/poll.h	2021-06-29 19:37:39.781036210 -0400
@@ -34,7 +34,8 @@
 /* 
  * structures and helpers for f_op->poll implementations
  */
-typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);
+typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *,
+	struct poll_table_struct *, unsigned long fixed_event);
 
 /*
  * Do not touch the structure directly, use the access functions
@@ -48,7 +49,15 @@
 static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
 {
 	if (p && p->_qproc && wait_address)
-		p->_qproc(filp, wait_address, p);
+		p->_qproc(filp, wait_address, p, 0);
+}
+
+static inline void poll_wait_fixed(struct file *filp,
+	wait_queue_head_t *wait_address, poll_table *p,
+	unsigned long fixed_event)
+{
+	if (p && p->_qproc && wait_address)
+		p->_qproc(filp, wait_address, p, fixed_event);
 }
 
 /*
@@ -93,6 +102,7 @@
 struct poll_table_entry {
 	struct file *filp;
 	__poll_t key;
+	unsigned long fixed_key;
 	wait_queue_entry_t wait;
 	wait_queue_head_t *wait_address;
 };
diff -Naur linux-5.12.13/include/linux/syscalls.h linux-5.12.13-r1/include/linux/syscalls.h
--- linux-5.12.13/include/linux/syscalls.h	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/include/linux/syscalls.h	2021-06-29 19:38:16.597704085 -0400
@@ -1363,6 +1363,9 @@
 long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
 			    const struct old_timespec32 __user *timeout);
+#ifdef CONFIG_DTRACE
+asmlinkage long sys_waitfd(int which, pid_t upid, int options, int flags);
+#endif
 
 int __sys_getsockopt(int fd, int level, int optname, char __user *optval,
 		int __user *optlen);
diff -Naur linux-5.12.13/include/uapi/asm-generic/unistd.h linux-5.12.13-r1/include/uapi/asm-generic/unistd.h
--- linux-5.12.13/include/uapi/asm-generic/unistd.h	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/include/uapi/asm-generic/unistd.h	2021-06-29 19:39:00.284372192 -0400
@@ -864,8 +864,11 @@
 #define __NR_mount_setattr 442
 __SYSCALL(__NR_mount_setattr, sys_mount_setattr)
 
+#define __NR_waitfd 473
+__SYSCALL(__NR_waitfd, sys_waitfd)
+
 #undef __NR_syscalls
-#define __NR_syscalls 443
+#define __NR_syscalls 474
 
 /*
  * 32 bit systems traditionally used different
diff -Naur linux-5.12.13/init/Kconfig linux-5.12.13-r1/init/Kconfig
--- linux-5.12.13/init/Kconfig	2021-06-29 19:26:03.007679962 -0400
+++ linux-5.12.13-r1/init/Kconfig	2021-06-29 19:39:35.661040029 -0400
@@ -1572,6 +1572,22 @@
 	  Disabling this option will cause the kernel to be built without
 	  support for epoll family of system calls.
 
+config WAITFD
+	bool "Enable waitfd() system call" if EXPERT
+	select ANON_INODES
+	default n
+	help
+	  Enable the waitfd() system call that allows receiving child state
+	  changes from a file descriptor.  This permits use of poll() to
+	  monitor waitpid() output simultaneously with other fd state changes,
+	  even if the waitpid() output is coming from thread-targetted sources
+	  such as ptrace().
+
+	  Note: this system call is not upstream: its syscall number is not
+	  finalized, so the call itself should only be used with caution.
+
+	  If unsure, say N.
+
 config SIGNALFD
 	bool "Enable signalfd() system call" if EXPERT
 	default y
diff -Naur linux-5.12.13/kernel/exit.c linux-5.12.13-r1/kernel/exit.c
--- linux-5.12.13/kernel/exit.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/kernel/exit.c	2021-06-29 19:40:40.917708843 -0400
@@ -1600,7 +1600,10 @@
 	enum pid_type type;
 	long ret;
 
-	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
+	/*
+	 * As for wait4(), except that waitfd() additionally needs WNOWAIT.
+	 */
+	if (options & ~(WNOHANG|WNOWAIT|WUNTRACED|WCONTINUED|
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
@@ -1655,7 +1658,13 @@
 		int, options, struct rusage __user *, ru)
 {
 	struct rusage r;
-	long err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);
+	long err;
+
+	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
+			__WNOTHREAD|__WCLONE|__WALL))
+		return -EINVAL;
+
+	err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL)
 
 	if (err > 0) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
diff -Naur linux-5.12.13/kernel/sys_ni.c linux-5.12.13-r1/kernel/sys_ni.c
--- linux-5.12.13/kernel/sys_ni.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/kernel/sys_ni.c	2021-06-29 19:41:08.511043080 -0400
@@ -393,6 +393,7 @@
  * include/uapi/asm-generic/unistd.h and wanted by >= 1 arch
  */
 
+COND_SYSCALL(waitfd);
 /* __ARCH_WANT_SYSCALL_NO_FLAGS */
 COND_SYSCALL(epoll_create);
 COND_SYSCALL(inotify_init);
diff -Naur linux-5.12.13/mm/memcontrol.c linux-5.12.13-r1/mm/memcontrol.c
--- linux-5.12.13/mm/memcontrol.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/mm/memcontrol.c	2021-06-29 19:41:29.151043758 -0400
@@ -4808,7 +4808,7 @@
 }
 
 static void memcg_event_ptable_queue_proc(struct file *file,
-		wait_queue_head_t *wqh, poll_table *pt)
+		wait_queue_head_t *wqh, poll_table *pt, unsigned long unused)
 {
 	struct mem_cgroup_event *event =
 		container_of(pt, struct mem_cgroup_event, pt);
diff -Naur linux-5.12.13/net/9p/trans_fd.c linux-5.12.13-r1/net/9p/trans_fd.c
--- linux-5.12.13/net/9p/trans_fd.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/net/9p/trans_fd.c	2021-06-29 19:42:03.351044886 -0400
@@ -547,7 +547,8 @@
  */
 
 static void
-p9_pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p)
+p9_pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p,
+	    unsigned long unused)
 {
 	struct p9_conn *m = container_of(p, struct p9_conn, pt);
 	struct p9_poll_wait *pwait = NULL;
diff -Naur linux-5.12.13/tools/testing/selftests/waitfd/Makefile linux-5.12.13-r1/tools/testing/selftests/waitfd/Makefile
--- linux-5.12.13/tools/testing/selftests/waitfd/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-5.12.13-r1/tools/testing/selftests/waitfd/Makefile	2021-06-29 19:42:37.421046010 -0400
@@ -0,0 +1,28 @@
+uname_M := $(shell uname -m 2>/dev/null || echo not)
+ARCH ?= $(shell echo $(uname_M) | sed -e s/i.86/i386/)
+ifeq ($(ARCH),i386)
+        ARCH := X86
+	CFLAGS := -DCONFIG_X86_32 -D__i386__
+endif
+ifeq ($(ARCH),x86_64)
+	ARCH := X86
+	CFLAGS := -DCONFIG_X86_64 -D__x86_64__
+endif
+
+CFLAGS += -I../../../../arch/x86/include/generated/
+CFLAGS += -I../../../../include/
+CFLAGS += -I../../../../usr/include/
+CFLAGS += -I../../../../arch/x86/include/
+
+all:
+ifeq ($(ARCH),X86)
+	gcc $(CFLAGS) waitfd.c -o waitfd
+else
+	echo "Not an x86 target, can't build waitfd selftest"
+endif
+
+run_tests: all
+	@./waitfd || echo "waitfd: [FAIL]"
+
+clean:
+	rm -fr ./waitfd
diff -Naur linux-5.12.13/tools/testing/selftests/waitfd/waitfd.c linux-5.12.13-r1/tools/testing/selftests/waitfd/waitfd.c
--- linux-5.12.13/tools/testing/selftests/waitfd/waitfd.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-5.12.13-r1/tools/testing/selftests/waitfd/waitfd.c	2021-06-29 19:42:55.517713269 -0400
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+/* waitfd testcase. */
+
+#define _GNU_SOURCE 1
+#include <linux/unistd.h>
+#include <sys/syscall.h>
+#include <sys/ptrace.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#include <poll.h>
+
+int waitfd(int which, pid_t upid, int options, int flags)
+{
+	return syscall(__NR_waitfd, which, upid, options, flags);
+}
+
+void sleeper(void)
+{
+	sleep(10);
+	exit(0);
+}
+
+int main (void)
+{
+	pid_t die_pid, ptrace_pid;
+	int die_fd, ptrace_fd;
+	int status;
+	struct pollfd pfd[2];
+	int procs_left = 2;
+
+	memset(pfd, 0, sizeof(pfd));
+
+	/*
+	 * Fork off two children, one of which waits for a ptrace().
+	 * Both just sleep after that.	Make sure we can use __WNOTHREAD,
+	 * __WALL, and WUNTRACED without getting an -EINVAL.
+	 */
+
+	die_pid = fork();
+
+	if (die_pid == 0)
+		sleeper();
+
+	ptrace_pid = fork();
+	if (ptrace_pid == 0) {
+		ptrace(PTRACE_TRACEME, 0, 0, 0);
+		sleeper();
+	}
+
+	die_fd = waitfd(P_PID, die_pid, 0, 0);
+	ptrace_fd = waitfd(P_PID, ptrace_pid, __WNOTHREAD | __WALL | WUNTRACED, 0);
+
+	if (die_fd < 0 || ptrace_fd < 0) {
+		perror("Cannot waitfd()");
+		exit(1);
+	}
+
+	pfd[0].fd = die_fd;
+	pfd[0].events = POLLIN;
+	pfd[1].fd = ptrace_fd;
+	pfd[1].events = POLLIN;
+
+	/*
+	 * Hit the ptrace PID with a signal
+	 */
+	kill(ptrace_pid, SIGABRT);
+
+	while (procs_left > 0) {
+		ssize_t bytes;
+
+		if (poll(pfd, 2, -1) < 0)
+			perror ("poll() failed");
+
+		if (pfd[0].revents != 0) {
+			bytes = read(die_fd, &status, sizeof(int));
+			if (bytes < sizeof(int)) {
+				fprintf(stderr, "Only read %zi bytes\n", bytes);
+				exit(1);
+			}
+
+			printf("die_fd returned %i via waitfd read: revents are %x\n",
+			       status, pfd[0].revents);
+			pfd[0].fd *= -1;
+			procs_left--;
+		}
+
+		if (pfd[1].revents != 0) {
+			pid_t check_pid;
+			status = 0;
+			check_pid = waitpid(ptrace_pid, &status, __WNOTHREAD |
+					    __WALL | WUNTRACED | WNOHANG);
+			if (check_pid < 0) {
+				fprintf(stderr, "waitpid() failed: %s\n",
+					strerror(errno));
+				exit(1);
+			}
+			if (check_pid != ptrace_pid) {
+				fprintf(stderr, "waitfd() said PID %i was ready, but waitpid() says it isn't: %i\n",
+				    ptrace_pid, check_pid);
+				exit(1);
+			}
+			printf("ptrace_fd returned status %i via waitpid; revents are %x\n",
+			       status, pfd[1].revents);
+			pfd[1].fd *= -1;
+			procs_left--;
+		}
+	}
+
+	return 0;
+}
diff -Naur linux-5.12.13/virt/kvm/eventfd.c linux-5.12.13-r1/virt/kvm/eventfd.c
--- linux-5.12.13/virt/kvm/eventfd.c	2021-06-23 08:44:11.000000000 -0400
+++ linux-5.12.13-r1/virt/kvm/eventfd.c	2021-06-29 19:43:18.501047359 -0400
@@ -237,7 +237,7 @@
 
 static void
 irqfd_ptable_queue_proc(struct file *file, wait_queue_head_t *wqh,
-			poll_table *pt)
+			poll_table *pt, unsigned long unused)
 {
 	struct kvm_kernel_irqfd *irqfd =
 		container_of(pt, struct kvm_kernel_irqfd, pt);
